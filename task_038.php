<?php
/*
 * Task 38. Максимально возможное число из массива
 * Задача: напишите функцию, которая принимает список не отрицательных целых чисел, упорядочивает их так, чтобы они составляли максимально возможное число.
 *
 * Например, в массиве [ 819, 6, 89, 402, 4023, 54, 5 ] наибольшее сформированное число равно 8981965544024023.
 *
 * Решение:
 * 1. мы момжем опираться только на первую цифру, соответсвенно нужно собрать по принципу от большего к меньшему.
 * В каждой подгруге формируем максимальную комбинацию.
 * Разбить на подстроки, что бы сократить количество итераций. Можно подумать над сокращением итераций и внутри подгруппю
 * Решение будет очень медленным, если будет много вариантов в результате перестановок
 *
 */
header("Content-Type: text/plain; charset=utf8"); // Без этого перенос строки не работает
//$arr = [819, 6, 89, 402, 4023, 54, 5]; // Исходный массив
$arr = [121, 12, 95];


// ----------------------------------------------------------------------------
// Решение №1
// ----------------------------------------------------------------------------

// Разложим по первой цифре исходный массив на группы
$res = [9 => null, 8 => null, 7 => null, 6 => null, 5 => null, 4 => null, 3 => null, 2 => null, 1 => null, 0 => null,];
foreach ($res as $rk => $rv){
  foreach ($arr as $ak => $av){
    if ($rk == substr((string)$av, 0, 1)){ // Определяем первую цифру
      $res[$rk][] = $av; // В каждой группе должен получится массив числе начинающихся на эту цифру
      unset($arr[$ak]); // Удалеям чтобы не повторялись
    }
  }
}

// В каждой группе нужно найти максимальную комбинацию значений
foreach ($res as $key => $subarr){
  $subarr = (array)$subarr; // Если в подмассиве остался null (на эту цифру не начинается ни одно число), то дальше foreach вернёт варниг, исключаем ошибку приведя к пустому массиву в этом случае

  $max = ''; // Максимальная комбинация для данной группы
  foreach ($subarr as $value) $max .= $value; // По умолчанию исходная комбинация максимальная

  // Нужно проверить, есть ли комбинация больше установленной по умолчанию
  if (count($subarr) > 1){
    $res2 = combo($subarr); // Получили все варианты перестановок
    foreach ($res2 as $k => $sub_res2){
      $max_tmp = '';
      foreach ($sub_res2 as $item) $max_tmp .= $item; // Формируем новые числа
      if ((int)$max < (int)$max_tmp) $max = $max_tmp;
    }
  }

  unset($res[$key]); // Удаляем массив чисел начинающихся на эту цифру
  $res[$key] = $max; // Записываем максимальную комбинацию для данной цифры
}

$out = '';
foreach ($res as $val) $out .= $val; // Формируем итоговое значение
echo $out . PHP_EOL;

/*
 * Рекурсивная функция, которая формирует все перестановки
 * Например для [1, 2, 3] на выходе должны получить
 * [1, 2, 3]
 * [1, 3, 2]
 * [2, 1, 3]
 * [2, 3, 1]
 * [3, 2, 1]
 * [3, 1, 2]
 *
 * Т.е. берем один элемент из последовательности и строим все варинты из оставшихся элементов
 */
function combo($arr){
  if (count($arr) == 2){ // Для двух элементов формируем два варианта руками
    $res[] = [reset($arr), end($arr)];
    $res[] = [end($arr), reset($arr)];
    return ($res);
  }
  foreach ($arr as $key => $value){
    // Получаем новый массив без элемента который сейчас рассматриваем
    $tmp = $arr;
    unset($tmp[$key]);

    $sub = combo($tmp); // Собираем все варинты перестановок из оставшихся элементов
    foreach ($sub as $item){ // Ко всем вариантам нужно добавить исключенный элемент
      array_push($item, $value);
      $res[] = $item; // Сохраняем последовательность одну
    }
  }
  return ($res);
}