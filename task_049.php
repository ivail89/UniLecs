<?php
/*
 * Task 49. Мышка и зернышки
 * Задача: Пол прямоугольной формы выложен плитками 1х1, на каждую из которых высыпано от 0 до K зернышек (K <= 30000). Размеры пола MxN.
 * Мышка выбегает из верхнего левого угла и двигается к входу в противоложном углу. Мышка может двигаться только вправо или вниз, собирая все зернышки с плитки, на ктр она находится.
 *
 * Входные данные: Дана матрица MxN (M,N <= 100). Матрица содержит кол-во зернышек в каждой плитке.
 * Вывести кол-во зернышек на каждом шаге маршрута мышки, при ктр она соберет наибольшее кол-во зернышек.
 *
 * Будем использовать рекурсию. Идея так как мышка может пойти либо направо, либо вниз, значит из исходной матрицы нужно получить две новые подматрицы удалив или верхнюю строку или левый столбец.
 * Например
 *
 * 1 2 3               2 3
 * 1 2 3 => 1 2 3  или 2 3
 * 1 2 3    1 2 3      2 3
 *
 * Максимальный маршрут из двух подматриц и будет направлением вниз или влево. Значит из новой матрицы (обрезанной) получаем две новые подматрицы и так далее.
 *
 * Делаем так до тех пор, пока не останет один столбец, строка или матрица 2*2
 *
 * Дальше рекурсивно получаем маршрут в обратном порядке
 */
header("Content-Type: text/plain; charset=utf8"); // Без этого перенос строки не работает

$arr = [
  [1, 5, 1, 1],
  [1, 1, 1, 1],
  [5, 5, 1, 1],
];

$arr1 = [
  [4, 5, 6, 7],
  [4, 5, 6, 7],
  [1, 2, 2, 3],
  [1, 4, 5, 6],
];

$arr2 = [
  [3, 2, 4],
  [3, 2, 4],
  [1, 5, 1]
];


// Функция поиска лучше маршрута
function bestRoute($arr){
  $countRow = count($arr); // Количестко строк в матрице
  $countColumn = count($arr[0]); // Количество столбцов в матрице
  $sum = 0;
  $route = '';
  if ($countRow == 1){ // Случай когда осталась одна строка
    foreach ($arr[0] as $value){
      $sum += $value; // Считаем сумму по прямой
      $route .= ' ' . $value; // и сохраняем маршрут
    }
    return ['sum' => $sum, 'route' => $route];
  }
  if ($countColumn == 1){ // Случай когда осталась один столбец
    foreach ($arr as $value){
      $sum += $value[0]; // Считаем сумму по прямой
      $route .= ' ' . $value[0]; // и сохраняем маршрут
    }
    return ['sum' => $sum, 'route' => $route];
  }
  if ($countRow == 2 && $countColumn == 2){ // Осталась матрица 2*2
    if ($arr[0][1] > $arr[1][0]){ // Т.к. начальная и конечная точка не изменны, нужно сравнить только промежуточный элемент
      return [ // Записываем максимальную сумму и маршрут
        'sum'   => $arr[0][0] + $arr[0][1] + $arr[1][1],
        'route' => $arr[0][0] . ' ' . $arr[0][1] . ' ' . $arr[1][1],
      ];
    } else {
      return [
        'sum'   => $arr[0][0] + $arr[1][0] + $arr[1][1],
        'route' => $arr[0][0] . ' ' . $arr[1][0] . ' ' . $arr[1][1],
      ];
    }
  }

  // Если ни один из трех случаев не был встречен ранее, то нужно получить максимальный маршрут в двух подматрицах
  $arrWithoutRow = bestRoute(deleteRow($arr));
  $arrWithoutColumn = bestRoute(deleteColumn($arr));

  // Не забываем к максимальному значению прибавить начальную точку
  if ($arrWithoutColumn['sum'] < $arrWithoutRow['sum']){
    return [
      'sum' => $arrWithoutRow['sum'] + $arr[0][0],
      'route' => $arr[0][0] . ' ' . $arrWithoutRow['route']
    ];
  } else {
    return [
      'sum' => $arrWithoutColumn['sum'] + $arr[0][0],
      'route' => $arr[0][0] . ' ' . $arrWithoutColumn['route']
    ];
  }

}

// Функция для удаления строки из матрицы
function deleteRow($arr){
  $res = array();
  $countRow = count($arr);
  for ($i=1; $i<$countRow; $i++){ // Копируем все строки кроме первой
    $res[] = $arr[$i];
  }
  return $res;
}

// Функция удаления столбца
// Копируем все элементы каждой строки, кроме первого столбца
// Не используем ансет, чтобы обнулить нумерацию
function deleteColumn($arr){
  $res = array();
  foreach ($arr as $row){
    $resRow = array();
    foreach ($row as $key=>$value){
      if ($key == 0) continue;
      $resRow[] = $value;
    }
    $res[] = $resRow;
  }
  return $res;
}

print_r(bestRoute($arr));
print_r(bestRoute($arr1));
print_r(bestRoute($arr2));