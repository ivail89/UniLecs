<?php
/*
 * Task 64. Одинаковый периметр
 * Задача: дана геометрическая фигура в виде квадратов (зеленого цвета),
 * каждый зеленый квадрат имеет хотя бы одну общую точку хотя бы с одним другим зеленым квадратом. Исходная фигура является связной.
 * Исходная фигура задается массивом точек (-100 <= x,y <= 100) левых нижних углов зеленых квадратов.
 * Нужно дорисовать заданную фигуру максимальным кол-вом квадртов желтого цвета таким образом, чтобы периметр новой фигуры оставался таким же.
 * Входные данные: массив координат левых нижних углов зеленых квадратов.
 * Вывод: кол-во желтых квадратов.
 * Написать программу, ктр по заданным координатам исходных квадратов найдет максимальное кол-во желтых квадратов,
 * ктр нужно дорисовать так, чтобы периметр новой фигуры не изменился.
 *
 * Пример: [ { x: 1, y: 1}, { x: 2, y: 1 }, { x: 2, y: 2 }]
 * Результат: 1
 */

include_once ('functions.php');
$arr1 = [
  [1,1],
  [2,1],
  [3,1],
  [3,2]
];

$arr2 = [
  [1, 1],
  [2, 1],
  [2, 2]
];

$arr = [
  [0, 0],
  [0, 1],
  [0, 2],
  [0, 4],

  [1, 1],
  [1, 2],
  [1, 3],
  [1, 4],

  [2, 1],
  [2, 3],
  [2, 4],

  [3, 0],
  [3, 1],
  [3, 2],
  [3, 3],
];

// Найдем крайние точки матрицы
list ($minX, $minY, $maxX, $maxY) = findEdgesPoint($arr);

// Создаем пустую матрицу, равную размерности входных данных
for ($i = $minX; $i < $maxX + 1; $i++){
  for ($j = $minY; $j < $maxY + 1; $j++) {
    $matrix // Первый индекс строка, второй столбец
      [$minY + $maxY - $j] // Смещаем в обратном порядке, чтобы индексы соответствовали системе координат
      [$i]
    = 0;
  }
}

// Наполнаяем матрицу входными точками
foreach ($arr as $line) {
  $matrix
    [$line[1]]
    [$line[0]]
  = 1;
}

// Считаем периметр
function countPerimeter($matrix, $minX, $minY, $maxX, $maxY){
  $initialPerimeter = 0;
  for ($i = $minX; $i < $maxX + 1; $i++){
    for ($j = $minY; $j < $maxY + 1; $j++) {
      if ($matrix[$j][$i] == 1 || $matrix[$j][$i] == 2){
        if (($i != $minX && $matrix[$j][$i-1] == 0) || $i == $minX) $initialPerimeter++;
        if (($j != $maxY && $matrix[$j+1][$i] == 0) || $j == $maxY) $initialPerimeter++;
        if (($i != $maxX && $matrix[$j][$i+1] == 0) || $i == $maxX) $initialPerimeter++;
        if (($j != $minY && $matrix[$j-1][$i] == 0) || $j == $minY) $initialPerimeter++;
      }
    }
  }
  return $initialPerimeter;
}

$initialPerimeter = countPerimeter($matrix, $minX, $minY, $maxX, $maxY);

$addedPoint = 0;
// Все пропуски можем смело заполнять, так как это приведет либо не изменит периметр или сократит его
for ($i = $minX; $i < $maxX + 1; $i++) {
  for ($j = $minY; $j < $maxY + 1; $j++) {
    if ($matrix[$j][$i] == 0) {
      $matrix[$j][$i] = 2;
      $addedPoint++;
    }
  }
}

$newPerimeter = countPerimeter($matrix, $minX, $minY, $maxX, $maxY);

if ($newPerimeter != $initialPerimeter) {
  // Если приклеить матрице строку или столбец, то периметр увеличится всего на 2, так как одна из сторон остается неизменной
  // При этом разница между новым и старым периметром будут отличатся друг от друга на четное число
  // Соответсвенно можно смело добавлять строку или столбец
  // В задаче сказано, добавить максимальное число квадратов, поэтоу добавлять будем по большей стороне
  $needMod = ($initialPerimeter - $newPerimeter) / 2;

  while ($needMod--){
    $height = count($matrix);
    $width = count($matrix[0]);
    if ($height > $width) { // Добавляем столбец
      foreach ($matrix as $key => $line) {
        $matrix[$key][] = 2;
      }
      $addedPoint += $height;
    } else { // Добавляем строку
      $matrix[] = array_fill($minX, $width, 2);
      $addedPoint += $width;
    }
  }
}

printMatrix($matrix);
echo $addedPoint;